# -*- coding: utf-8 -*-
"""Untitledg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kgsJH5UXWUUptj5TKBPn0IWq8nX3r2m3
"""

import cv2
import numpy as np

pip install opencv-python

"""Load /Read image"""

#load an image using "imread" speciying the path to image
img = cv2.imread("/content/Modi.jpg")



"""Lets take a closer look at how images are stored"""

print(img)



"""Shape gives the dimensions o the image array"""

img.shape
#The 3D dimensions are 1358 pixels in height * 1500 pixels wide
#3 means that there are 3 compents (RGB) that make up this image



"""Display the image"""

#To display our image variable we use imshow
# The first paramater will be tittle shown on image window
#The second paramater is the image variable
import cv2
from google.colab.patches import cv2_imshow

# Load an image from file
img = cv2.imread('/content/Modi.jpg')  # Replace with your actual image path

# Check if the image was loaded successfully
if img is not None:
    # Show the image
    cv2_imshow(img)
else:
    print("Image not found or path is incorrect.")

cv2.waitKey(2000)
cv2.destroyAllWindows()

"""Save image"""

import cv2

# Read the image
img = cv2.imread("/content/Modi.jpg")

# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Save the grayscale image
cv2.imwrite("/content/pm_b_w.jpg", gray)

"""Resize image"""

# Load the image
img = cv2.imread("/content/Modi.jpg")

# Resize the image to 500x500
resized_image = cv2.resize(img, (500, 500))

# Convert to grayscale
gray = cv2.cvtColor(resized_image, cv2.COLOR_BGR2GRAY)

# Display the grayscale image in Colab
cv2_imshow(gray)  # Use this instead of cv2.imshow

img.shape[0]*0.5

img.shape[1]*0.5

"""Face Detection using HAAR Cascade Classifiers"""

import cv2
from google.colab.patches import cv2_imshow

# Load the Haar Cascade for face detection
face_classifier = cv2.CascadeClassifier("/content/haarcascade_frontalface_default.xml")

# Load and resize image
img = cv2.imread("/content/Modi.jpg")
img = cv2.resize(img, (500, 500))

# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Detect faces
faces = face_classifier.detectMultiScale(gray, 1.3, 5)

# Draw rectangles around detected faces
for (x, y, w, h) in faces:
    cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the image with detected faces
cv2_imshow(img)

#scale factor spcifies how much we reduce the image size each time we scale
#E.g in face detection we typically use 1.3 this means we reduce the image by 30% each timme
#smaller values like 1.05 will take longer to compute but will increase the rate of detection

##Min Neighbors**
#specifies the number of neighbors each potential window should have in order to consider it a positive detection
#typically set b/w 3-6
#it acts as sensitivity setting low values will sometimes detect multiples faces over a single
#high values will ensure less false positive but you may miss some false

print(faces)

import cv2
from google.colab.patches import cv2_imshow

# Download the Haar cascade file if not already present
!wget -nc https://github.com/opencv/opencv/raw/master/data/haarcascades/haarcascade_frontalface_default.xml

# Load the classifier (FIXED typo)
face_classifier = cv2.CascadeClassifier("/content/haarcascade_frontalface_default.xml")

# Load and resize the image
image = cv2.imread("/content/Modi.jpg")
image = cv2.resize(image, (500, 500))

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Detect faces (FIXED function name)
faces = face_classifier.detectMultiScale(gray, 1.05, 5)

# Check if faces were found (FIXED condition)
if len(faces) == 0:
    print("No faces found.")
else:
    # Draw rectangles around detected faces
    for (x, y, w, h) in faces:
        cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 100), 2)

    # Display the image using cv2_imshow (FIXED for Colab)
    cv2_imshow(image)
    cv2.waitKey()
    cv2.destroyAllWindows()



"""Face & Eye Detection using HAAR Cascade Classifier in image"""

# Load Haar cascade classifiers (fixed typo: capital 'C')
face_classifier = cv2.CascadeClassifier("/content/haarcascade_frontalface_default.xml")
eye_classifier = cv2.CascadeClassifier("/content/haarcascade_eye.xml")

# Read and resize image
image = cv2.imread("/content/Modi.jpg")
image = cv2.resize(image, (500, 500))

# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Detect faces
faces = face_classifier.detectMultiScale(gray, 1.3, 5)

if len(faces) == 0:
    print("No faces found.")
else:
    for (x, y, w, h) in faces:
        cv2.rectangle(image, (x, y), (x + w, y + h), (255, 0, 0), 2)
        roi_gray = gray[y:y+h, x:x+w]
        roi_color = image[y:y+h, x:x+w]

        eyes = eye_classifier.detectMultiScale(roi_gray)
        for (ex, ey, ew, eh) in eyes:
            cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (0, 255, 0), 2)

# Show the result in Colab
cv2_imshow(image)

"""Capture a Video

"""

#doing same face recognition with the webcam
import cv2
video = cv2.VideoCapture(0)#----0webcam

while True:
  check,frame = video.read()
  gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
  cv2.imshow(" Video", gray)
  if cv2.waitKey(1)==ord("q"):
      break
video.release()
cv2.destroyAllWindows()

"""Face & Eye Detection using HAAR CascadeClassifiers"""

#Load Haar cascade classifiers
face_classifier = cv2.CascadeClassifier("/content/haarcascade_frontalface_default.xml")
eye_classifier = cv2.CascadeClassifier("/content/haarcascade_eye.xml")
def detect(gray,frame):
  faces = face_classifier.detectMultiScale(gray,1.3,5)
  for (x,y,w,h)in faces:
      cv2.rectangle(frame,(x,y,(x+w,y+h),(255,0,0),2))
      roi_gray = gray[y:y+h,x:x+w]
      roi_color=frame[y:y+h,x:x+w]
      eyes = eye_classifier.detectMultiScale(roi_gray,1.1,3)
      for(ex,ey,ew,eh)in eyes:
         cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)
return frame

video = cv2.VideoCapture(0)
while True:
    check,frame = video.read()
    gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
    canvas= detect(gray,frame)
    cv2.imshow("video",canvas)
    if cv2.waitKey(1)==ord("q"):
       break
video.release()
cv2.destroyAllWindows()

"""pedistrian Detection"""

import cv2

#create our body classifier
body_classifier = cv2.CascadeClassifier("/content/haarcascade_fullbody.xml")

#Inititiate video capture for video file
cap = cv2.VideoCapture("/content/walking.avi")

frame_count = 0
while cap.isOpened():
    check, frame = cap.read()
    if not check:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    bodies = body_classifier.detectMultiScale(gray, 1.2, 3)

    for (x, y, w, h) in bodies:
        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 255), 2)

    # Show one frame every 10 iterations to avoid flooding output
    if frame_count % 10 == 0:
        cv2_imshow(frame)

    frame_count += 1

cap.release()

import time



import cv2
from google.colab.patches import cv2_imshow
from google.colab import files

# Upload 'cars.xml' (from GitHub)
uploaded = files.upload()  # Upload the downloaded 'cars.xml'

# Load the cascade
cars_classifier = cv2.CascadeClassifier("/content/haarcascade_car.xml")

# Upload your video file
uploaded = files.upload()  # Upload your video file, e.g., 'cars.mp4'

# Load video
cap = cv2.VideoCapture("/content/cars.avi")

frame_count = 0
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    cars = cars_classifier.detectMultiScale(gray, 1.4, 2)

    for (x, y, w, h) in cars:
        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 255), 2)

    if frame_count % 10 == 0:
        cv2_imshow(frame)

    frame_count += 1

cap.release()

